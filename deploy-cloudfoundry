#!/usr/bin/env ruby

require 'rubygems'
require 'json'
require 'net/https'
require 'uri'
require 'time'

require 'inifile'
require 'pry'
require 'aws-sdk'
require 'dotenv/load'
require 'rest-client'

if File.file? "#{ENV['HOME']}/.aws/config"
  aws_config = IniFile.new(filename: "#{ENV['HOME']}/.aws/config", encoding: 'UTF-8')

  if aws_config.has_section? 'default'
    region = aws_config['default']['region'] || 'us-east-1'
    Aws.config.update({region: region})
  end
end

if File.file? "#{ENV['HOME']}/.aws/credentials"
  aws_creds = IniFile.new(filename: "#{ENV['HOME']}/.aws/credentials", encoding: 'UTF-8')

  if aws_creds.has_section? 'default'
    access_key = aws_creds['default']['aws_access_key_id'] || raise('no aws_access_key_id configured')
    secret_key = aws_creds['default']['aws_secret_access_key'] || raise('no aws_secret_access_key configured')
    Aws.config.update({credentials: Aws::Credentials.new(access_key, secret_key)})
  end
end

PCF_PIVNET_SLUG = 'elastic-runtime'
PIVNET_TOKEN = ENV.fetch('PIVNET_TOKEN')
RDS_USERNAME = ENV.fetch('RDS_USERNAME')
RDS_PASSWORD = ENV.fetch('RDS_PASSWORD')
STACK_NAME = ARGV[0]

def formatted_duration total_seconds
  hours = total_seconds / (60 * 60)
  minutes = (total_seconds / 60) % 60
  seconds = total_seconds % 60

  [
      hours > 0 ? '%02dh' % [hours] : nil,
      minutes > 0 ? '%02dm' % [minutes] : nil,
      seconds > 0 ? '%02ds' % [seconds] : nil
  ].compact.join(' ')
end

def format_stack_event(stack_event)
  [
      stack_event.timestamp.localtime.strftime('%H:%M:%S'),
      stack_event.resource_type,
      stack_event.logical_resource_id,
      stack_event.resource_status,
      stack_event.resource_status_reason
  ].join(' ')
end

def fetch_stack_events(cf_client, stack_id, last_event_id)
  new_events = []
  next_token = nil

  loop do
    response = cf_client.describe_stack_events(
        stack_name: stack_id,
        next_token: next_token
    )

    stack_events = response.stack_events
    recent_events = last_event_id ? stack_events.take_while { |e| e.event_id != last_event_id } : stack_events

    new_events.concat(recent_events)

    break if recent_events.size != stack_events.size

    next_token = response.next_token
    break if !next_token
  end

  new_events.reverse
end

def pivnet_request(url, method: 'GET')
  request_args = {
      method: method,
      url: url,
      open_timeout: 10,
      read_timeout: 10,
      headers: {
          accept: :json,
          'Authorization': "Token #{PIVNET_TOKEN}"
      }
  }

  RestClient::Request.new(request_args)
end

require 'pp'

print "fetching PCF releases from pivnet... "
releases_url = "https://network.pivotal.io/api/v2/products/#{PCF_PIVNET_SLUG}/releases"
response = pivnet_request(releases_url).execute
pcf_release = JSON.parse(response.body).fetch('releases').fetch(0)
puts "found PCF v#{pcf_release.fetch('version')}"

pcf_product_files_url = pcf_release.fetch('_links')
                            .fetch('product_files')
                            .fetch('href')
response = pivnet_request(pcf_product_files_url).execute

print "finding PCF CloudFormation downloads... "
product_files = JSON.parse(response.body).fetch('product_files')
product_file = product_files.find { |f| f.fetch('aws_object_key').end_with? '_cloudformation.json' }
download_url = product_file.fetch('_links')
                   .fetch('download')
                   .fetch('href')

cloudformation_template = begin
  pivnet_request(download_url).execute.body
rescue RestClient::RequestFailed => e
  if e.http_code == 451
    print 'accepting EULA for you... '
    accept_eula_href = JSON.parse(e.http_body)
                           .fetch('_links')
                           .fetch('eula_agreement')
                           .fetch('href')
    pivnet_request(accept_eula_href, method: 'POST').execute
    print 'accepted '
    pivnet_request(download_url).execute.body
  else
    raise e
  end
end
puts "downloaded #{product_file['name']} v#{product_file['file_version']}"

PCF_REGION = Aws.config[:region]
print "finding SSH keypairs in #{PCF_REGION}... "
ec2_client = Aws::EC2::Client.new
key_pair = ec2_client.describe_key_pairs.key_pairs.fetch(0)
puts "found #{key_pair.key_name}"

print "finding SSL cert ARN in #{PCF_REGION}... "
iam_client = Aws::IAM::Client.new
ssl_cert = iam_client.list_server_certificates.server_certificate_metadata_list.fetch(0)
puts "found #{ssl_cert.arn}"

puts "creating AWS CF stack #{STACK_NAME}... "
stack_create_start = Time.now
cf_client = Aws::CloudFormation::Client.new
response = cf_client.create_stack(
    {
        stack_name: STACK_NAME,
        template_body: cloudformation_template,
        parameters: [
            {
                parameter_key: '01NATKeyPair',
                parameter_value: key_pair.key_name,
            },
            {
                parameter_key: '05RdsUsername',
                parameter_value: RDS_USERNAME,
            },
            {
                parameter_key: '06RdsPassword',
                parameter_value: RDS_PASSWORD,
            },
            {
                parameter_key: '07SSLCertificateARN',
                parameter_value: ssl_cert.arn,
            }
        ],
        capabilities: %w(CAPABILITY_NAMED_IAM CAPABILITY_IAM)
    }
)
puts "=> creating #{response.stack_id}"

cf_client.wait_until(:stack_create_complete) do |waiter|
  pcf_last_event_id = nil
  opsman_last_event_id = nil
  opsman_stack_id = nil

  waiter.before_wait do |attempts, response|
    new_events = fetch_stack_events(cf_client, STACK_NAME, pcf_last_event_id)
    last_event = new_events.last
    pcf_last_event_id = last_event.event_id if last_event

    new_events.each do |event|
      puts format_stack_event(event)
    end

    opsman_stack_event = new_events.find do |e|
      e.logical_resource_id == 'OpsManStack' &&
          e.resource_status == 'CREATE_IN_PROGRESS' &&
          e.resource_status_reason
    end
    if opsman_stack_event
      opsman_stack_id = opsman_stack_event.physical_resource_id
      puts "OpsManStack is #{opsman_stack_id}"
      pp opsman_stack_event
    end

    if opsman_stack_id
      new_events = fetch_stack_events(cf_client, opsman_stack_id, opsman_last_event_id)
      last_event = new_events.last
      opsman_last_event_id = last_event.event_id if last_event
      new_events.each do |event|
        puts format_stack_event(event)
      end
    end
  end
end

stack_create_finish = Time.now
puts "deployed PCF stack in #{formatted_duration(stack_create_finish - stack_create_start)}"

